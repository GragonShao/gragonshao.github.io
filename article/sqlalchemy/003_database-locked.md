# SQLAlchemy: "sqlite3.OperationalError: database is locked"

## 错误呈现

![错误呈现第1张](../../asserts/images/2024-03-21_0/1.jpg)

![错误呈现第2张](../../asserts/images/2024-03-21_0/2.jpg)

![错误呈现第3张](../../asserts/images/2024-03-21_0/3.jpg)



## 尝试解决

1. 怀疑是其它测试导致数据库锁表，所以跳过其它测试用例

	![尝试解决第1张](../../asserts/images/2024-03-21_0/4.jpg)

	原本错误的测试居然通过了

	![尝试解决第2张](../../asserts/images/2024-03-21_0/5.jpg)

2. 随便再加载一个测试用例

	看到测试又失败了

	![尝试解决第3张](../../asserts/images/2024-03-21_0/6.jpg)

3. 想起错误之前的改动
   1. 即将sqlite内存数据库改成了文件数据库
	![尝试解决第4张](../../asserts/images/2024-03-21_0/9.jpg)
   2. . 将数据库的id（number）从String(32)改为了BINARY(16)，来压缩存储空间
	![尝试解决第5张](../../asserts/images/2024-03-21_0/11.jpg)

	现将原本的数据库删除，再运行一次测试

	![尝试解决第6张](../../asserts/images/2024-03-21_0/10.jpg)

	测试又可以通过了

	![尝试解决第7张](../../asserts/images/2024-03-21_0/7.jpg)

4. 运行所有测试

	![尝试解决第8张](../../asserts/images/2024-03-21_0/8.jpg)



## 总结

1. sqlite的内存模式不能够看出所有的问题。这个bug的产生是因为不放心仅仅用内存数据库进行测试。而pycharm能够直接看到sqlite数据库文件里面的情况，所以使用文件模式也可以更好的观察到问题。目前有发现到了一个bug，将会在下一篇文章中尝试解决
2. 这个bug不是完全没学到东西。能够看出，在sqlite和sqlalchemy同时使用的情况下，当数据库的schema发生的修改，报出的错误竟然是数据库锁表
